// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ProtoMessages.proto

#ifndef PROTOBUF_ProtoMessages_2eproto__INCLUDED
#define PROTOBUF_ProtoMessages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_ProtoMessages_2eproto();
void protobuf_InitDefaults_ProtoMessages_2eproto();
void protobuf_AssignDesc_ProtoMessages_2eproto();
void protobuf_ShutdownFile_ProtoMessages_2eproto();

class BoardUpdate;
class ClientRequest;
class CreateRoomRequest;
class GameOver;
class JoinRoomRequest;
class LobbyUpdate;
class LoginRequest;
class LoginResponse;
class Map;
class PlayerInfo;
class PlayerList;
class QuitGameRequest;
class QuitRoom;
class RoomList;
class RoomUpdate;
class ServerResponse;
class Square;
class TestRequest;
class TileClickedRequest;

enum GameState {
  NONE = 0,
  LOGIN = 1,
  LOBBY = 2,
  GAME = 3,
  OVER = 4,
  GameState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GameState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GameState_IsValid(int value);
const GameState GameState_MIN = NONE;
const GameState GameState_MAX = OVER;
const int GameState_ARRAYSIZE = GameState_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameState_descriptor();
inline const ::std::string& GameState_Name(GameState value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameState_descriptor(), value);
}
inline bool GameState_Parse(
    const ::std::string& name, GameState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameState>(
    GameState_descriptor(), name, value);
}
// ===================================================================

class Square : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Square) */ {
 public:
  Square();
  virtual ~Square();

  Square(const Square& from);

  inline Square& operator=(const Square& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Square& default_instance();

  static const Square* internal_default_instance();

  void Swap(Square* other);

  // implements Message ----------------------------------------------

  inline Square* New() const { return New(NULL); }

  Square* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Square& from);
  void MergeFrom(const Square& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Square* other);
  void UnsafeMergeFrom(const Square& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 squareType = 1;
  void clear_squaretype();
  static const int kSquareTypeFieldNumber = 1;
  ::google::protobuf::int32 squaretype() const;
  void set_squaretype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.Square)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 squaretype_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Square> Square_default_instance_;

// -------------------------------------------------------------------

class Map : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.Map) */ {
 public:
  Map();
  virtual ~Map();

  Map(const Map& from);

  inline Map& operator=(const Map& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Map& default_instance();

  static const Map* internal_default_instance();

  void Swap(Map* other);

  // implements Message ----------------------------------------------

  inline Map* New() const { return New(NULL); }

  Map* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Map& from);
  void MergeFrom(const Map& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Map* other);
  void UnsafeMergeFrom(const Map& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 numExposedSquares = 1;
  void clear_numexposedsquares();
  static const int kNumExposedSquaresFieldNumber = 1;
  ::google::protobuf::int32 numexposedsquares() const;
  void set_numexposedsquares(::google::protobuf::int32 value);

  // optional int32 mapWidth = 2;
  void clear_mapwidth();
  static const int kMapWidthFieldNumber = 2;
  ::google::protobuf::int32 mapwidth() const;
  void set_mapwidth(::google::protobuf::int32 value);

  // optional int32 mapHeight = 3;
  void clear_mapheight();
  static const int kMapHeightFieldNumber = 3;
  ::google::protobuf::int32 mapheight() const;
  void set_mapheight(::google::protobuf::int32 value);

  // repeated .Proto.Square squares = 4;
  int squares_size() const;
  void clear_squares();
  static const int kSquaresFieldNumber = 4;
  const ::Proto::Square& squares(int index) const;
  ::Proto::Square* mutable_squares(int index);
  ::Proto::Square* add_squares();
  ::google::protobuf::RepeatedPtrField< ::Proto::Square >*
      mutable_squares();
  const ::google::protobuf::RepeatedPtrField< ::Proto::Square >&
      squares() const;

  // @@protoc_insertion_point(class_scope:Proto.Map)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Proto::Square > squares_;
  ::google::protobuf::int32 numexposedsquares_;
  ::google::protobuf::int32 mapwidth_;
  ::google::protobuf::int32 mapheight_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Map> Map_default_instance_;

// -------------------------------------------------------------------

class ServerResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.ServerResponse) */ {
 public:
  ServerResponse();
  virtual ~ServerResponse();

  ServerResponse(const ServerResponse& from);

  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerResponse& default_instance();

  static const ServerResponse* internal_default_instance();

  void Swap(ServerResponse* other);

  // implements Message ----------------------------------------------

  inline ServerResponse* New() const { return New(NULL); }

  ServerResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerResponse& from);
  void MergeFrom(const ServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ServerResponse* other);
  void UnsafeMergeFrom(const ServerResponse& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Proto.LoginResponse loginResponse = 1;
  bool has_loginresponse() const;
  void clear_loginresponse();
  static const int kLoginResponseFieldNumber = 1;
  const ::Proto::LoginResponse& loginresponse() const;
  ::Proto::LoginResponse* mutable_loginresponse();
  ::Proto::LoginResponse* release_loginresponse();
  void set_allocated_loginresponse(::Proto::LoginResponse* loginresponse);

  // optional .Proto.PlayerList playerList = 2;
  bool has_playerlist() const;
  void clear_playerlist();
  static const int kPlayerListFieldNumber = 2;
  const ::Proto::PlayerList& playerlist() const;
  ::Proto::PlayerList* mutable_playerlist();
  ::Proto::PlayerList* release_playerlist();
  void set_allocated_playerlist(::Proto::PlayerList* playerlist);

  // optional .Proto.GameState gameState = 3;
  void clear_gamestate();
  static const int kGameStateFieldNumber = 3;
  ::Proto::GameState gamestate() const;
  void set_gamestate(::Proto::GameState value);

  // optional .Proto.BoardUpdate boardUpdate = 4;
  bool has_boardupdate() const;
  void clear_boardupdate();
  static const int kBoardUpdateFieldNumber = 4;
  const ::Proto::BoardUpdate& boardupdate() const;
  ::Proto::BoardUpdate* mutable_boardupdate();
  ::Proto::BoardUpdate* release_boardupdate();
  void set_allocated_boardupdate(::Proto::BoardUpdate* boardupdate);

  // optional .Proto.GameOver gameOver = 5;
  bool has_gameover() const;
  void clear_gameover();
  static const int kGameOverFieldNumber = 5;
  const ::Proto::GameOver& gameover() const;
  ::Proto::GameOver* mutable_gameover();
  ::Proto::GameOver* release_gameover();
  void set_allocated_gameover(::Proto::GameOver* gameover);

  // optional .Proto.LobbyUpdate lobbyUpdate = 6;
  bool has_lobbyupdate() const;
  void clear_lobbyupdate();
  static const int kLobbyUpdateFieldNumber = 6;
  const ::Proto::LobbyUpdate& lobbyupdate() const;
  ::Proto::LobbyUpdate* mutable_lobbyupdate();
  ::Proto::LobbyUpdate* release_lobbyupdate();
  void set_allocated_lobbyupdate(::Proto::LobbyUpdate* lobbyupdate);

  // optional .Proto.RoomUpdate roomUpdate = 7;
  bool has_roomupdate() const;
  void clear_roomupdate();
  static const int kRoomUpdateFieldNumber = 7;
  const ::Proto::RoomUpdate& roomupdate() const;
  ::Proto::RoomUpdate* mutable_roomupdate();
  ::Proto::RoomUpdate* release_roomupdate();
  void set_allocated_roomupdate(::Proto::RoomUpdate* roomupdate);

  // @@protoc_insertion_point(class_scope:Proto.ServerResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::LoginResponse* loginresponse_;
  ::Proto::PlayerList* playerlist_;
  ::Proto::BoardUpdate* boardupdate_;
  ::Proto::GameOver* gameover_;
  ::Proto::LobbyUpdate* lobbyupdate_;
  ::Proto::RoomUpdate* roomupdate_;
  int gamestate_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ServerResponse> ServerResponse_default_instance_;

// -------------------------------------------------------------------

class RoomUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.RoomUpdate) */ {
 public:
  RoomUpdate();
  virtual ~RoomUpdate();

  RoomUpdate(const RoomUpdate& from);

  inline RoomUpdate& operator=(const RoomUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomUpdate& default_instance();

  static const RoomUpdate* internal_default_instance();

  void Swap(RoomUpdate* other);

  // implements Message ----------------------------------------------

  inline RoomUpdate* New() const { return New(NULL); }

  RoomUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomUpdate& from);
  void MergeFrom(const RoomUpdate& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomUpdate* other);
  void UnsafeMergeFrom(const RoomUpdate& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Proto.PlayerList playerList = 1;
  bool has_playerlist() const;
  void clear_playerlist();
  static const int kPlayerListFieldNumber = 1;
  const ::Proto::PlayerList& playerlist() const;
  ::Proto::PlayerList* mutable_playerlist();
  ::Proto::PlayerList* release_playerlist();
  void set_allocated_playerlist(::Proto::PlayerList* playerlist);

  // optional .Proto.Map mapUpdate = 2;
  bool has_mapupdate() const;
  void clear_mapupdate();
  static const int kMapUpdateFieldNumber = 2;
  const ::Proto::Map& mapupdate() const;
  ::Proto::Map* mutable_mapupdate();
  ::Proto::Map* release_mapupdate();
  void set_allocated_mapupdate(::Proto::Map* mapupdate);

  // @@protoc_insertion_point(class_scope:Proto.RoomUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::PlayerList* playerlist_;
  ::Proto::Map* mapupdate_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RoomUpdate> RoomUpdate_default_instance_;

// -------------------------------------------------------------------

class LobbyUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.LobbyUpdate) */ {
 public:
  LobbyUpdate();
  virtual ~LobbyUpdate();

  LobbyUpdate(const LobbyUpdate& from);

  inline LobbyUpdate& operator=(const LobbyUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LobbyUpdate& default_instance();

  static const LobbyUpdate* internal_default_instance();

  void Swap(LobbyUpdate* other);

  // implements Message ----------------------------------------------

  inline LobbyUpdate* New() const { return New(NULL); }

  LobbyUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LobbyUpdate& from);
  void MergeFrom(const LobbyUpdate& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LobbyUpdate* other);
  void UnsafeMergeFrom(const LobbyUpdate& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Proto.PlayerList playerList = 1;
  bool has_playerlist() const;
  void clear_playerlist();
  static const int kPlayerListFieldNumber = 1;
  const ::Proto::PlayerList& playerlist() const;
  ::Proto::PlayerList* mutable_playerlist();
  ::Proto::PlayerList* release_playerlist();
  void set_allocated_playerlist(::Proto::PlayerList* playerlist);

  // optional .Proto.RoomList roomList = 2;
  bool has_roomlist() const;
  void clear_roomlist();
  static const int kRoomListFieldNumber = 2;
  const ::Proto::RoomList& roomlist() const;
  ::Proto::RoomList* mutable_roomlist();
  ::Proto::RoomList* release_roomlist();
  void set_allocated_roomlist(::Proto::RoomList* roomlist);

  // @@protoc_insertion_point(class_scope:Proto.LobbyUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::PlayerList* playerlist_;
  ::Proto::RoomList* roomlist_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LobbyUpdate> LobbyUpdate_default_instance_;

// -------------------------------------------------------------------

class RoomList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.RoomList) */ {
 public:
  RoomList();
  virtual ~RoomList();

  RoomList(const RoomList& from);

  inline RoomList& operator=(const RoomList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomList& default_instance();

  static const RoomList* internal_default_instance();

  void Swap(RoomList* other);

  // implements Message ----------------------------------------------

  inline RoomList* New() const { return New(NULL); }

  RoomList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomList& from);
  void MergeFrom(const RoomList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RoomList* other);
  void UnsafeMergeFrom(const RoomList& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 numRooms = 1;
  void clear_numrooms();
  static const int kNumRoomsFieldNumber = 1;
  ::google::protobuf::int32 numrooms() const;
  void set_numrooms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.RoomList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 numrooms_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<RoomList> RoomList_default_instance_;

// -------------------------------------------------------------------

class PlayerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.PlayerInfo) */ {
 public:
  PlayerInfo();
  virtual ~PlayerInfo();

  PlayerInfo(const PlayerInfo& from);

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerInfo& default_instance();

  static const PlayerInfo* internal_default_instance();

  void Swap(PlayerInfo* other);

  // implements Message ----------------------------------------------

  inline PlayerInfo* New() const { return New(NULL); }

  PlayerInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerInfo& from);
  void MergeFrom(const PlayerInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerInfo* other);
  void UnsafeMergeFrom(const PlayerInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 score = 2;
  void clear_score();
  static const int kScoreFieldNumber = 2;
  ::google::protobuf::int32 score() const;
  void set_score(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.PlayerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 score_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PlayerInfo> PlayerInfo_default_instance_;

// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  static const LoginResponse* internal_default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const { return New(NULL); }

  LoginResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginResponse* other);
  void UnsafeMergeFrom(const LoginResponse& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.LoginResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 token_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LoginResponse> LoginResponse_default_instance_;

// -------------------------------------------------------------------

class BoardUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.BoardUpdate) */ {
 public:
  BoardUpdate();
  virtual ~BoardUpdate();

  BoardUpdate(const BoardUpdate& from);

  inline BoardUpdate& operator=(const BoardUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoardUpdate& default_instance();

  static const BoardUpdate* internal_default_instance();

  void Swap(BoardUpdate* other);

  // implements Message ----------------------------------------------

  inline BoardUpdate* New() const { return New(NULL); }

  BoardUpdate* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoardUpdate& from);
  void MergeFrom(const BoardUpdate& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoardUpdate* other);
  void UnsafeMergeFrom(const BoardUpdate& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Proto.Map map = 1;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 1;
  const ::Proto::Map& map() const;
  ::Proto::Map* mutable_map();
  ::Proto::Map* release_map();
  void set_allocated_map(::Proto::Map* map);

  // @@protoc_insertion_point(class_scope:Proto.BoardUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::Map* map_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BoardUpdate> BoardUpdate_default_instance_;

// -------------------------------------------------------------------

class PlayerList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.PlayerList) */ {
 public:
  PlayerList();
  virtual ~PlayerList();

  PlayerList(const PlayerList& from);

  inline PlayerList& operator=(const PlayerList& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerList& default_instance();

  static const PlayerList* internal_default_instance();

  void Swap(PlayerList* other);

  // implements Message ----------------------------------------------

  inline PlayerList* New() const { return New(NULL); }

  PlayerList* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerList& from);
  void MergeFrom(const PlayerList& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerList* other);
  void UnsafeMergeFrom(const PlayerList& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Proto.PlayerInfo playerInfo = 1;
  int playerinfo_size() const;
  void clear_playerinfo();
  static const int kPlayerInfoFieldNumber = 1;
  const ::Proto::PlayerInfo& playerinfo(int index) const;
  ::Proto::PlayerInfo* mutable_playerinfo(int index);
  ::Proto::PlayerInfo* add_playerinfo();
  ::google::protobuf::RepeatedPtrField< ::Proto::PlayerInfo >*
      mutable_playerinfo();
  const ::google::protobuf::RepeatedPtrField< ::Proto::PlayerInfo >&
      playerinfo() const;

  // @@protoc_insertion_point(class_scope:Proto.PlayerList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Proto::PlayerInfo > playerinfo_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PlayerList> PlayerList_default_instance_;

// -------------------------------------------------------------------

class GameOver : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.GameOver) */ {
 public:
  GameOver();
  virtual ~GameOver();

  GameOver(const GameOver& from);

  inline GameOver& operator=(const GameOver& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameOver& default_instance();

  static const GameOver* internal_default_instance();

  void Swap(GameOver* other);

  // implements Message ----------------------------------------------

  inline GameOver* New() const { return New(NULL); }

  GameOver* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameOver& from);
  void MergeFrom(const GameOver& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GameOver* other);
  void UnsafeMergeFrom(const GameOver& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Proto.PlayerList playerList = 1;
  bool has_playerlist() const;
  void clear_playerlist();
  static const int kPlayerListFieldNumber = 1;
  const ::Proto::PlayerList& playerlist() const;
  ::Proto::PlayerList* mutable_playerlist();
  ::Proto::PlayerList* release_playerlist();
  void set_allocated_playerlist(::Proto::PlayerList* playerlist);

  // optional .Proto.Map map = 2;
  bool has_map() const;
  void clear_map();
  static const int kMapFieldNumber = 2;
  const ::Proto::Map& map() const;
  ::Proto::Map* mutable_map();
  ::Proto::Map* release_map();
  void set_allocated_map(::Proto::Map* map);

  // @@protoc_insertion_point(class_scope:Proto.GameOver)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::PlayerList* playerlist_;
  ::Proto::Map* map_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<GameOver> GameOver_default_instance_;

// -------------------------------------------------------------------

class ClientRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.ClientRequest) */ {
 public:
  ClientRequest();
  virtual ~ClientRequest();

  ClientRequest(const ClientRequest& from);

  inline ClientRequest& operator=(const ClientRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequest& default_instance();

  static const ClientRequest* internal_default_instance();

  void Swap(ClientRequest* other);

  // implements Message ----------------------------------------------

  inline ClientRequest* New() const { return New(NULL); }

  ClientRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequest& from);
  void MergeFrom(const ClientRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientRequest* other);
  void UnsafeMergeFrom(const ClientRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Proto.LoginRequest loginRequest = 1;
  bool has_loginrequest() const;
  void clear_loginrequest();
  static const int kLoginRequestFieldNumber = 1;
  const ::Proto::LoginRequest& loginrequest() const;
  ::Proto::LoginRequest* mutable_loginrequest();
  ::Proto::LoginRequest* release_loginrequest();
  void set_allocated_loginrequest(::Proto::LoginRequest* loginrequest);

  // optional .Proto.CreateRoomRequest createRoom = 2;
  bool has_createroom() const;
  void clear_createroom();
  static const int kCreateRoomFieldNumber = 2;
  const ::Proto::CreateRoomRequest& createroom() const;
  ::Proto::CreateRoomRequest* mutable_createroom();
  ::Proto::CreateRoomRequest* release_createroom();
  void set_allocated_createroom(::Proto::CreateRoomRequest* createroom);

  // optional .Proto.JoinRoomRequest joinRoom = 3;
  bool has_joinroom() const;
  void clear_joinroom();
  static const int kJoinRoomFieldNumber = 3;
  const ::Proto::JoinRoomRequest& joinroom() const;
  ::Proto::JoinRoomRequest* mutable_joinroom();
  ::Proto::JoinRoomRequest* release_joinroom();
  void set_allocated_joinroom(::Proto::JoinRoomRequest* joinroom);

  // optional .Proto.QuitGameRequest quitGame = 4;
  bool has_quitgame() const;
  void clear_quitgame();
  static const int kQuitGameFieldNumber = 4;
  const ::Proto::QuitGameRequest& quitgame() const;
  ::Proto::QuitGameRequest* mutable_quitgame();
  ::Proto::QuitGameRequest* release_quitgame();
  void set_allocated_quitgame(::Proto::QuitGameRequest* quitgame);

  // optional .Proto.TileClickedRequest tileClicked = 5;
  bool has_tileclicked() const;
  void clear_tileclicked();
  static const int kTileClickedFieldNumber = 5;
  const ::Proto::TileClickedRequest& tileclicked() const;
  ::Proto::TileClickedRequest* mutable_tileclicked();
  ::Proto::TileClickedRequest* release_tileclicked();
  void set_allocated_tileclicked(::Proto::TileClickedRequest* tileclicked);

  // optional .Proto.TestRequest testRequest = 6;
  bool has_testrequest() const;
  void clear_testrequest();
  static const int kTestRequestFieldNumber = 6;
  const ::Proto::TestRequest& testrequest() const;
  ::Proto::TestRequest* mutable_testrequest();
  ::Proto::TestRequest* release_testrequest();
  void set_allocated_testrequest(::Proto::TestRequest* testrequest);

  // optional .Proto.QuitRoom quitRoom = 7;
  bool has_quitroom() const;
  void clear_quitroom();
  static const int kQuitRoomFieldNumber = 7;
  const ::Proto::QuitRoom& quitroom() const;
  ::Proto::QuitRoom* mutable_quitroom();
  ::Proto::QuitRoom* release_quitroom();
  void set_allocated_quitroom(::Proto::QuitRoom* quitroom);

  // @@protoc_insertion_point(class_scope:Proto.ClientRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Proto::LoginRequest* loginrequest_;
  ::Proto::CreateRoomRequest* createroom_;
  ::Proto::JoinRoomRequest* joinroom_;
  ::Proto::QuitGameRequest* quitgame_;
  ::Proto::TileClickedRequest* tileclicked_;
  ::Proto::TestRequest* testrequest_;
  ::Proto::QuitRoom* quitroom_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ClientRequest> ClientRequest_default_instance_;

// -------------------------------------------------------------------

class QuitRoom : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.QuitRoom) */ {
 public:
  QuitRoom();
  virtual ~QuitRoom();

  QuitRoom(const QuitRoom& from);

  inline QuitRoom& operator=(const QuitRoom& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuitRoom& default_instance();

  static const QuitRoom* internal_default_instance();

  void Swap(QuitRoom* other);

  // implements Message ----------------------------------------------

  inline QuitRoom* New() const { return New(NULL); }

  QuitRoom* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuitRoom& from);
  void MergeFrom(const QuitRoom& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QuitRoom* other);
  void UnsafeMergeFrom(const QuitRoom& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.QuitRoom)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 token_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<QuitRoom> QuitRoom_default_instance_;

// -------------------------------------------------------------------

class TestRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.TestRequest) */ {
 public:
  TestRequest();
  virtual ~TestRequest();

  TestRequest(const TestRequest& from);

  inline TestRequest& operator=(const TestRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestRequest& default_instance();

  static const TestRequest* internal_default_instance();

  void Swap(TestRequest* other);

  // implements Message ----------------------------------------------

  inline TestRequest* New() const { return New(NULL); }

  TestRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TestRequest& from);
  void MergeFrom(const TestRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TestRequest* other);
  void UnsafeMergeFrom(const TestRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.TestRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 token_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TestRequest> TestRequest_default_instance_;

// -------------------------------------------------------------------

class QuitGameRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.QuitGameRequest) */ {
 public:
  QuitGameRequest();
  virtual ~QuitGameRequest();

  QuitGameRequest(const QuitGameRequest& from);

  inline QuitGameRequest& operator=(const QuitGameRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const QuitGameRequest& default_instance();

  static const QuitGameRequest* internal_default_instance();

  void Swap(QuitGameRequest* other);

  // implements Message ----------------------------------------------

  inline QuitGameRequest* New() const { return New(NULL); }

  QuitGameRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const QuitGameRequest& from);
  void MergeFrom(const QuitGameRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(QuitGameRequest* other);
  void UnsafeMergeFrom(const QuitGameRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.QuitGameRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 token_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<QuitGameRequest> QuitGameRequest_default_instance_;

// -------------------------------------------------------------------

class TileClickedRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.TileClickedRequest) */ {
 public:
  TileClickedRequest();
  virtual ~TileClickedRequest();

  TileClickedRequest(const TileClickedRequest& from);

  inline TileClickedRequest& operator=(const TileClickedRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TileClickedRequest& default_instance();

  static const TileClickedRequest* internal_default_instance();

  void Swap(TileClickedRequest* other);

  // implements Message ----------------------------------------------

  inline TileClickedRequest* New() const { return New(NULL); }

  TileClickedRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TileClickedRequest& from);
  void MergeFrom(const TileClickedRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TileClickedRequest* other);
  void UnsafeMergeFrom(const TileClickedRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // optional int32 tileIndex = 2;
  void clear_tileindex();
  static const int kTileIndexFieldNumber = 2;
  ::google::protobuf::int32 tileindex() const;
  void set_tileindex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.TileClickedRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 token_;
  ::google::protobuf::int32 tileindex_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TileClickedRequest> TileClickedRequest_default_instance_;

// -------------------------------------------------------------------

class JoinRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.JoinRoomRequest) */ {
 public:
  JoinRoomRequest();
  virtual ~JoinRoomRequest();

  JoinRoomRequest(const JoinRoomRequest& from);

  inline JoinRoomRequest& operator=(const JoinRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinRoomRequest& default_instance();

  static const JoinRoomRequest* internal_default_instance();

  void Swap(JoinRoomRequest* other);

  // implements Message ----------------------------------------------

  inline JoinRoomRequest* New() const { return New(NULL); }

  JoinRoomRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JoinRoomRequest& from);
  void MergeFrom(const JoinRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JoinRoomRequest* other);
  void UnsafeMergeFrom(const JoinRoomRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // optional int32 roomNumber = 2;
  void clear_roomnumber();
  static const int kRoomNumberFieldNumber = 2;
  ::google::protobuf::int32 roomnumber() const;
  void set_roomnumber(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.JoinRoomRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 token_;
  ::google::protobuf::int32 roomnumber_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<JoinRoomRequest> JoinRoomRequest_default_instance_;

// -------------------------------------------------------------------

class CreateRoomRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.CreateRoomRequest) */ {
 public:
  CreateRoomRequest();
  virtual ~CreateRoomRequest();

  CreateRoomRequest(const CreateRoomRequest& from);

  inline CreateRoomRequest& operator=(const CreateRoomRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoomRequest& default_instance();

  static const CreateRoomRequest* internal_default_instance();

  void Swap(CreateRoomRequest* other);

  // implements Message ----------------------------------------------

  inline CreateRoomRequest* New() const { return New(NULL); }

  CreateRoomRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateRoomRequest& from);
  void MergeFrom(const CreateRoomRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateRoomRequest* other);
  void UnsafeMergeFrom(const CreateRoomRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 token = 1;
  void clear_token();
  static const int kTokenFieldNumber = 1;
  ::google::protobuf::int32 token() const;
  void set_token(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Proto.CreateRoomRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 token_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CreateRoomRequest> CreateRoomRequest_default_instance_;

// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Proto.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  static const LoginRequest* internal_default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const { return New(NULL); }

  LoginRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginRequest* other);
  void UnsafeMergeFrom(const LoginRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string login = 1;
  void clear_login();
  static const int kLoginFieldNumber = 1;
  const ::std::string& login() const;
  void set_login(const ::std::string& value);
  void set_login(const char* value);
  void set_login(const char* value, size_t size);
  ::std::string* mutable_login();
  ::std::string* release_login();
  void set_allocated_login(::std::string* login);

  // optional string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:Proto.LoginRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr login_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ProtoMessages_2eproto_impl();
  friend void  protobuf_AddDesc_ProtoMessages_2eproto_impl();
  friend void protobuf_AssignDesc_ProtoMessages_2eproto();
  friend void protobuf_ShutdownFile_ProtoMessages_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LoginRequest> LoginRequest_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Square

// optional int32 squareType = 1;
inline void Square::clear_squaretype() {
  squaretype_ = 0;
}
inline ::google::protobuf::int32 Square::squaretype() const {
  // @@protoc_insertion_point(field_get:Proto.Square.squareType)
  return squaretype_;
}
inline void Square::set_squaretype(::google::protobuf::int32 value) {
  
  squaretype_ = value;
  // @@protoc_insertion_point(field_set:Proto.Square.squareType)
}

inline const Square* Square::internal_default_instance() {
  return &Square_default_instance_.get();
}
// -------------------------------------------------------------------

// Map

// optional int32 numExposedSquares = 1;
inline void Map::clear_numexposedsquares() {
  numexposedsquares_ = 0;
}
inline ::google::protobuf::int32 Map::numexposedsquares() const {
  // @@protoc_insertion_point(field_get:Proto.Map.numExposedSquares)
  return numexposedsquares_;
}
inline void Map::set_numexposedsquares(::google::protobuf::int32 value) {
  
  numexposedsquares_ = value;
  // @@protoc_insertion_point(field_set:Proto.Map.numExposedSquares)
}

// optional int32 mapWidth = 2;
inline void Map::clear_mapwidth() {
  mapwidth_ = 0;
}
inline ::google::protobuf::int32 Map::mapwidth() const {
  // @@protoc_insertion_point(field_get:Proto.Map.mapWidth)
  return mapwidth_;
}
inline void Map::set_mapwidth(::google::protobuf::int32 value) {
  
  mapwidth_ = value;
  // @@protoc_insertion_point(field_set:Proto.Map.mapWidth)
}

// optional int32 mapHeight = 3;
inline void Map::clear_mapheight() {
  mapheight_ = 0;
}
inline ::google::protobuf::int32 Map::mapheight() const {
  // @@protoc_insertion_point(field_get:Proto.Map.mapHeight)
  return mapheight_;
}
inline void Map::set_mapheight(::google::protobuf::int32 value) {
  
  mapheight_ = value;
  // @@protoc_insertion_point(field_set:Proto.Map.mapHeight)
}

// repeated .Proto.Square squares = 4;
inline int Map::squares_size() const {
  return squares_.size();
}
inline void Map::clear_squares() {
  squares_.Clear();
}
inline const ::Proto::Square& Map::squares(int index) const {
  // @@protoc_insertion_point(field_get:Proto.Map.squares)
  return squares_.Get(index);
}
inline ::Proto::Square* Map::mutable_squares(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.Map.squares)
  return squares_.Mutable(index);
}
inline ::Proto::Square* Map::add_squares() {
  // @@protoc_insertion_point(field_add:Proto.Map.squares)
  return squares_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::Square >*
Map::mutable_squares() {
  // @@protoc_insertion_point(field_mutable_list:Proto.Map.squares)
  return &squares_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::Square >&
Map::squares() const {
  // @@protoc_insertion_point(field_list:Proto.Map.squares)
  return squares_;
}

inline const Map* Map::internal_default_instance() {
  return &Map_default_instance_.get();
}
// -------------------------------------------------------------------

// ServerResponse

// optional .Proto.LoginResponse loginResponse = 1;
inline bool ServerResponse::has_loginresponse() const {
  return this != internal_default_instance() && loginresponse_ != NULL;
}
inline void ServerResponse::clear_loginresponse() {
  if (GetArenaNoVirtual() == NULL && loginresponse_ != NULL) delete loginresponse_;
  loginresponse_ = NULL;
}
inline const ::Proto::LoginResponse& ServerResponse::loginresponse() const {
  // @@protoc_insertion_point(field_get:Proto.ServerResponse.loginResponse)
  return loginresponse_ != NULL ? *loginresponse_
                         : *::Proto::LoginResponse::internal_default_instance();
}
inline ::Proto::LoginResponse* ServerResponse::mutable_loginresponse() {
  
  if (loginresponse_ == NULL) {
    loginresponse_ = new ::Proto::LoginResponse;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ServerResponse.loginResponse)
  return loginresponse_;
}
inline ::Proto::LoginResponse* ServerResponse::release_loginresponse() {
  // @@protoc_insertion_point(field_release:Proto.ServerResponse.loginResponse)
  
  ::Proto::LoginResponse* temp = loginresponse_;
  loginresponse_ = NULL;
  return temp;
}
inline void ServerResponse::set_allocated_loginresponse(::Proto::LoginResponse* loginresponse) {
  delete loginresponse_;
  loginresponse_ = loginresponse;
  if (loginresponse) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ServerResponse.loginResponse)
}

// optional .Proto.PlayerList playerList = 2;
inline bool ServerResponse::has_playerlist() const {
  return this != internal_default_instance() && playerlist_ != NULL;
}
inline void ServerResponse::clear_playerlist() {
  if (GetArenaNoVirtual() == NULL && playerlist_ != NULL) delete playerlist_;
  playerlist_ = NULL;
}
inline const ::Proto::PlayerList& ServerResponse::playerlist() const {
  // @@protoc_insertion_point(field_get:Proto.ServerResponse.playerList)
  return playerlist_ != NULL ? *playerlist_
                         : *::Proto::PlayerList::internal_default_instance();
}
inline ::Proto::PlayerList* ServerResponse::mutable_playerlist() {
  
  if (playerlist_ == NULL) {
    playerlist_ = new ::Proto::PlayerList;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ServerResponse.playerList)
  return playerlist_;
}
inline ::Proto::PlayerList* ServerResponse::release_playerlist() {
  // @@protoc_insertion_point(field_release:Proto.ServerResponse.playerList)
  
  ::Proto::PlayerList* temp = playerlist_;
  playerlist_ = NULL;
  return temp;
}
inline void ServerResponse::set_allocated_playerlist(::Proto::PlayerList* playerlist) {
  delete playerlist_;
  playerlist_ = playerlist;
  if (playerlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ServerResponse.playerList)
}

// optional .Proto.GameState gameState = 3;
inline void ServerResponse::clear_gamestate() {
  gamestate_ = 0;
}
inline ::Proto::GameState ServerResponse::gamestate() const {
  // @@protoc_insertion_point(field_get:Proto.ServerResponse.gameState)
  return static_cast< ::Proto::GameState >(gamestate_);
}
inline void ServerResponse::set_gamestate(::Proto::GameState value) {
  
  gamestate_ = value;
  // @@protoc_insertion_point(field_set:Proto.ServerResponse.gameState)
}

// optional .Proto.BoardUpdate boardUpdate = 4;
inline bool ServerResponse::has_boardupdate() const {
  return this != internal_default_instance() && boardupdate_ != NULL;
}
inline void ServerResponse::clear_boardupdate() {
  if (GetArenaNoVirtual() == NULL && boardupdate_ != NULL) delete boardupdate_;
  boardupdate_ = NULL;
}
inline const ::Proto::BoardUpdate& ServerResponse::boardupdate() const {
  // @@protoc_insertion_point(field_get:Proto.ServerResponse.boardUpdate)
  return boardupdate_ != NULL ? *boardupdate_
                         : *::Proto::BoardUpdate::internal_default_instance();
}
inline ::Proto::BoardUpdate* ServerResponse::mutable_boardupdate() {
  
  if (boardupdate_ == NULL) {
    boardupdate_ = new ::Proto::BoardUpdate;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ServerResponse.boardUpdate)
  return boardupdate_;
}
inline ::Proto::BoardUpdate* ServerResponse::release_boardupdate() {
  // @@protoc_insertion_point(field_release:Proto.ServerResponse.boardUpdate)
  
  ::Proto::BoardUpdate* temp = boardupdate_;
  boardupdate_ = NULL;
  return temp;
}
inline void ServerResponse::set_allocated_boardupdate(::Proto::BoardUpdate* boardupdate) {
  delete boardupdate_;
  boardupdate_ = boardupdate;
  if (boardupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ServerResponse.boardUpdate)
}

// optional .Proto.GameOver gameOver = 5;
inline bool ServerResponse::has_gameover() const {
  return this != internal_default_instance() && gameover_ != NULL;
}
inline void ServerResponse::clear_gameover() {
  if (GetArenaNoVirtual() == NULL && gameover_ != NULL) delete gameover_;
  gameover_ = NULL;
}
inline const ::Proto::GameOver& ServerResponse::gameover() const {
  // @@protoc_insertion_point(field_get:Proto.ServerResponse.gameOver)
  return gameover_ != NULL ? *gameover_
                         : *::Proto::GameOver::internal_default_instance();
}
inline ::Proto::GameOver* ServerResponse::mutable_gameover() {
  
  if (gameover_ == NULL) {
    gameover_ = new ::Proto::GameOver;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ServerResponse.gameOver)
  return gameover_;
}
inline ::Proto::GameOver* ServerResponse::release_gameover() {
  // @@protoc_insertion_point(field_release:Proto.ServerResponse.gameOver)
  
  ::Proto::GameOver* temp = gameover_;
  gameover_ = NULL;
  return temp;
}
inline void ServerResponse::set_allocated_gameover(::Proto::GameOver* gameover) {
  delete gameover_;
  gameover_ = gameover;
  if (gameover) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ServerResponse.gameOver)
}

// optional .Proto.LobbyUpdate lobbyUpdate = 6;
inline bool ServerResponse::has_lobbyupdate() const {
  return this != internal_default_instance() && lobbyupdate_ != NULL;
}
inline void ServerResponse::clear_lobbyupdate() {
  if (GetArenaNoVirtual() == NULL && lobbyupdate_ != NULL) delete lobbyupdate_;
  lobbyupdate_ = NULL;
}
inline const ::Proto::LobbyUpdate& ServerResponse::lobbyupdate() const {
  // @@protoc_insertion_point(field_get:Proto.ServerResponse.lobbyUpdate)
  return lobbyupdate_ != NULL ? *lobbyupdate_
                         : *::Proto::LobbyUpdate::internal_default_instance();
}
inline ::Proto::LobbyUpdate* ServerResponse::mutable_lobbyupdate() {
  
  if (lobbyupdate_ == NULL) {
    lobbyupdate_ = new ::Proto::LobbyUpdate;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ServerResponse.lobbyUpdate)
  return lobbyupdate_;
}
inline ::Proto::LobbyUpdate* ServerResponse::release_lobbyupdate() {
  // @@protoc_insertion_point(field_release:Proto.ServerResponse.lobbyUpdate)
  
  ::Proto::LobbyUpdate* temp = lobbyupdate_;
  lobbyupdate_ = NULL;
  return temp;
}
inline void ServerResponse::set_allocated_lobbyupdate(::Proto::LobbyUpdate* lobbyupdate) {
  delete lobbyupdate_;
  lobbyupdate_ = lobbyupdate;
  if (lobbyupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ServerResponse.lobbyUpdate)
}

// optional .Proto.RoomUpdate roomUpdate = 7;
inline bool ServerResponse::has_roomupdate() const {
  return this != internal_default_instance() && roomupdate_ != NULL;
}
inline void ServerResponse::clear_roomupdate() {
  if (GetArenaNoVirtual() == NULL && roomupdate_ != NULL) delete roomupdate_;
  roomupdate_ = NULL;
}
inline const ::Proto::RoomUpdate& ServerResponse::roomupdate() const {
  // @@protoc_insertion_point(field_get:Proto.ServerResponse.roomUpdate)
  return roomupdate_ != NULL ? *roomupdate_
                         : *::Proto::RoomUpdate::internal_default_instance();
}
inline ::Proto::RoomUpdate* ServerResponse::mutable_roomupdate() {
  
  if (roomupdate_ == NULL) {
    roomupdate_ = new ::Proto::RoomUpdate;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ServerResponse.roomUpdate)
  return roomupdate_;
}
inline ::Proto::RoomUpdate* ServerResponse::release_roomupdate() {
  // @@protoc_insertion_point(field_release:Proto.ServerResponse.roomUpdate)
  
  ::Proto::RoomUpdate* temp = roomupdate_;
  roomupdate_ = NULL;
  return temp;
}
inline void ServerResponse::set_allocated_roomupdate(::Proto::RoomUpdate* roomupdate) {
  delete roomupdate_;
  roomupdate_ = roomupdate;
  if (roomupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ServerResponse.roomUpdate)
}

inline const ServerResponse* ServerResponse::internal_default_instance() {
  return &ServerResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// RoomUpdate

// optional .Proto.PlayerList playerList = 1;
inline bool RoomUpdate::has_playerlist() const {
  return this != internal_default_instance() && playerlist_ != NULL;
}
inline void RoomUpdate::clear_playerlist() {
  if (GetArenaNoVirtual() == NULL && playerlist_ != NULL) delete playerlist_;
  playerlist_ = NULL;
}
inline const ::Proto::PlayerList& RoomUpdate::playerlist() const {
  // @@protoc_insertion_point(field_get:Proto.RoomUpdate.playerList)
  return playerlist_ != NULL ? *playerlist_
                         : *::Proto::PlayerList::internal_default_instance();
}
inline ::Proto::PlayerList* RoomUpdate::mutable_playerlist() {
  
  if (playerlist_ == NULL) {
    playerlist_ = new ::Proto::PlayerList;
  }
  // @@protoc_insertion_point(field_mutable:Proto.RoomUpdate.playerList)
  return playerlist_;
}
inline ::Proto::PlayerList* RoomUpdate::release_playerlist() {
  // @@protoc_insertion_point(field_release:Proto.RoomUpdate.playerList)
  
  ::Proto::PlayerList* temp = playerlist_;
  playerlist_ = NULL;
  return temp;
}
inline void RoomUpdate::set_allocated_playerlist(::Proto::PlayerList* playerlist) {
  delete playerlist_;
  playerlist_ = playerlist;
  if (playerlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.RoomUpdate.playerList)
}

// optional .Proto.Map mapUpdate = 2;
inline bool RoomUpdate::has_mapupdate() const {
  return this != internal_default_instance() && mapupdate_ != NULL;
}
inline void RoomUpdate::clear_mapupdate() {
  if (GetArenaNoVirtual() == NULL && mapupdate_ != NULL) delete mapupdate_;
  mapupdate_ = NULL;
}
inline const ::Proto::Map& RoomUpdate::mapupdate() const {
  // @@protoc_insertion_point(field_get:Proto.RoomUpdate.mapUpdate)
  return mapupdate_ != NULL ? *mapupdate_
                         : *::Proto::Map::internal_default_instance();
}
inline ::Proto::Map* RoomUpdate::mutable_mapupdate() {
  
  if (mapupdate_ == NULL) {
    mapupdate_ = new ::Proto::Map;
  }
  // @@protoc_insertion_point(field_mutable:Proto.RoomUpdate.mapUpdate)
  return mapupdate_;
}
inline ::Proto::Map* RoomUpdate::release_mapupdate() {
  // @@protoc_insertion_point(field_release:Proto.RoomUpdate.mapUpdate)
  
  ::Proto::Map* temp = mapupdate_;
  mapupdate_ = NULL;
  return temp;
}
inline void RoomUpdate::set_allocated_mapupdate(::Proto::Map* mapupdate) {
  delete mapupdate_;
  mapupdate_ = mapupdate;
  if (mapupdate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.RoomUpdate.mapUpdate)
}

inline const RoomUpdate* RoomUpdate::internal_default_instance() {
  return &RoomUpdate_default_instance_.get();
}
// -------------------------------------------------------------------

// LobbyUpdate

// optional .Proto.PlayerList playerList = 1;
inline bool LobbyUpdate::has_playerlist() const {
  return this != internal_default_instance() && playerlist_ != NULL;
}
inline void LobbyUpdate::clear_playerlist() {
  if (GetArenaNoVirtual() == NULL && playerlist_ != NULL) delete playerlist_;
  playerlist_ = NULL;
}
inline const ::Proto::PlayerList& LobbyUpdate::playerlist() const {
  // @@protoc_insertion_point(field_get:Proto.LobbyUpdate.playerList)
  return playerlist_ != NULL ? *playerlist_
                         : *::Proto::PlayerList::internal_default_instance();
}
inline ::Proto::PlayerList* LobbyUpdate::mutable_playerlist() {
  
  if (playerlist_ == NULL) {
    playerlist_ = new ::Proto::PlayerList;
  }
  // @@protoc_insertion_point(field_mutable:Proto.LobbyUpdate.playerList)
  return playerlist_;
}
inline ::Proto::PlayerList* LobbyUpdate::release_playerlist() {
  // @@protoc_insertion_point(field_release:Proto.LobbyUpdate.playerList)
  
  ::Proto::PlayerList* temp = playerlist_;
  playerlist_ = NULL;
  return temp;
}
inline void LobbyUpdate::set_allocated_playerlist(::Proto::PlayerList* playerlist) {
  delete playerlist_;
  playerlist_ = playerlist;
  if (playerlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.LobbyUpdate.playerList)
}

// optional .Proto.RoomList roomList = 2;
inline bool LobbyUpdate::has_roomlist() const {
  return this != internal_default_instance() && roomlist_ != NULL;
}
inline void LobbyUpdate::clear_roomlist() {
  if (GetArenaNoVirtual() == NULL && roomlist_ != NULL) delete roomlist_;
  roomlist_ = NULL;
}
inline const ::Proto::RoomList& LobbyUpdate::roomlist() const {
  // @@protoc_insertion_point(field_get:Proto.LobbyUpdate.roomList)
  return roomlist_ != NULL ? *roomlist_
                         : *::Proto::RoomList::internal_default_instance();
}
inline ::Proto::RoomList* LobbyUpdate::mutable_roomlist() {
  
  if (roomlist_ == NULL) {
    roomlist_ = new ::Proto::RoomList;
  }
  // @@protoc_insertion_point(field_mutable:Proto.LobbyUpdate.roomList)
  return roomlist_;
}
inline ::Proto::RoomList* LobbyUpdate::release_roomlist() {
  // @@protoc_insertion_point(field_release:Proto.LobbyUpdate.roomList)
  
  ::Proto::RoomList* temp = roomlist_;
  roomlist_ = NULL;
  return temp;
}
inline void LobbyUpdate::set_allocated_roomlist(::Proto::RoomList* roomlist) {
  delete roomlist_;
  roomlist_ = roomlist;
  if (roomlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.LobbyUpdate.roomList)
}

inline const LobbyUpdate* LobbyUpdate::internal_default_instance() {
  return &LobbyUpdate_default_instance_.get();
}
// -------------------------------------------------------------------

// RoomList

// optional int32 numRooms = 1;
inline void RoomList::clear_numrooms() {
  numrooms_ = 0;
}
inline ::google::protobuf::int32 RoomList::numrooms() const {
  // @@protoc_insertion_point(field_get:Proto.RoomList.numRooms)
  return numrooms_;
}
inline void RoomList::set_numrooms(::google::protobuf::int32 value) {
  
  numrooms_ = value;
  // @@protoc_insertion_point(field_set:Proto.RoomList.numRooms)
}

inline const RoomList* RoomList::internal_default_instance() {
  return &RoomList_default_instance_.get();
}
// -------------------------------------------------------------------

// PlayerInfo

// optional string name = 1;
inline void PlayerInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerInfo::name() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.PlayerInfo.name)
}
inline void PlayerInfo::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.PlayerInfo.name)
}
inline ::std::string* PlayerInfo::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Proto.PlayerInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerInfo::release_name() {
  // @@protoc_insertion_point(field_release:Proto.PlayerInfo.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Proto.PlayerInfo.name)
}

// optional int32 score = 2;
inline void PlayerInfo::clear_score() {
  score_ = 0;
}
inline ::google::protobuf::int32 PlayerInfo::score() const {
  // @@protoc_insertion_point(field_get:Proto.PlayerInfo.score)
  return score_;
}
inline void PlayerInfo::set_score(::google::protobuf::int32 value) {
  
  score_ = value;
  // @@protoc_insertion_point(field_set:Proto.PlayerInfo.score)
}

inline const PlayerInfo* PlayerInfo::internal_default_instance() {
  return &PlayerInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// LoginResponse

// optional int32 token = 1;
inline void LoginResponse::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 LoginResponse::token() const {
  // @@protoc_insertion_point(field_get:Proto.LoginResponse.token)
  return token_;
}
inline void LoginResponse::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:Proto.LoginResponse.token)
}

inline const LoginResponse* LoginResponse::internal_default_instance() {
  return &LoginResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// BoardUpdate

// optional .Proto.Map map = 1;
inline bool BoardUpdate::has_map() const {
  return this != internal_default_instance() && map_ != NULL;
}
inline void BoardUpdate::clear_map() {
  if (GetArenaNoVirtual() == NULL && map_ != NULL) delete map_;
  map_ = NULL;
}
inline const ::Proto::Map& BoardUpdate::map() const {
  // @@protoc_insertion_point(field_get:Proto.BoardUpdate.map)
  return map_ != NULL ? *map_
                         : *::Proto::Map::internal_default_instance();
}
inline ::Proto::Map* BoardUpdate::mutable_map() {
  
  if (map_ == NULL) {
    map_ = new ::Proto::Map;
  }
  // @@protoc_insertion_point(field_mutable:Proto.BoardUpdate.map)
  return map_;
}
inline ::Proto::Map* BoardUpdate::release_map() {
  // @@protoc_insertion_point(field_release:Proto.BoardUpdate.map)
  
  ::Proto::Map* temp = map_;
  map_ = NULL;
  return temp;
}
inline void BoardUpdate::set_allocated_map(::Proto::Map* map) {
  delete map_;
  map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.BoardUpdate.map)
}

inline const BoardUpdate* BoardUpdate::internal_default_instance() {
  return &BoardUpdate_default_instance_.get();
}
// -------------------------------------------------------------------

// PlayerList

// repeated .Proto.PlayerInfo playerInfo = 1;
inline int PlayerList::playerinfo_size() const {
  return playerinfo_.size();
}
inline void PlayerList::clear_playerinfo() {
  playerinfo_.Clear();
}
inline const ::Proto::PlayerInfo& PlayerList::playerinfo(int index) const {
  // @@protoc_insertion_point(field_get:Proto.PlayerList.playerInfo)
  return playerinfo_.Get(index);
}
inline ::Proto::PlayerInfo* PlayerList::mutable_playerinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Proto.PlayerList.playerInfo)
  return playerinfo_.Mutable(index);
}
inline ::Proto::PlayerInfo* PlayerList::add_playerinfo() {
  // @@protoc_insertion_point(field_add:Proto.PlayerList.playerInfo)
  return playerinfo_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::Proto::PlayerInfo >*
PlayerList::mutable_playerinfo() {
  // @@protoc_insertion_point(field_mutable_list:Proto.PlayerList.playerInfo)
  return &playerinfo_;
}
inline const ::google::protobuf::RepeatedPtrField< ::Proto::PlayerInfo >&
PlayerList::playerinfo() const {
  // @@protoc_insertion_point(field_list:Proto.PlayerList.playerInfo)
  return playerinfo_;
}

inline const PlayerList* PlayerList::internal_default_instance() {
  return &PlayerList_default_instance_.get();
}
// -------------------------------------------------------------------

// GameOver

// optional .Proto.PlayerList playerList = 1;
inline bool GameOver::has_playerlist() const {
  return this != internal_default_instance() && playerlist_ != NULL;
}
inline void GameOver::clear_playerlist() {
  if (GetArenaNoVirtual() == NULL && playerlist_ != NULL) delete playerlist_;
  playerlist_ = NULL;
}
inline const ::Proto::PlayerList& GameOver::playerlist() const {
  // @@protoc_insertion_point(field_get:Proto.GameOver.playerList)
  return playerlist_ != NULL ? *playerlist_
                         : *::Proto::PlayerList::internal_default_instance();
}
inline ::Proto::PlayerList* GameOver::mutable_playerlist() {
  
  if (playerlist_ == NULL) {
    playerlist_ = new ::Proto::PlayerList;
  }
  // @@protoc_insertion_point(field_mutable:Proto.GameOver.playerList)
  return playerlist_;
}
inline ::Proto::PlayerList* GameOver::release_playerlist() {
  // @@protoc_insertion_point(field_release:Proto.GameOver.playerList)
  
  ::Proto::PlayerList* temp = playerlist_;
  playerlist_ = NULL;
  return temp;
}
inline void GameOver::set_allocated_playerlist(::Proto::PlayerList* playerlist) {
  delete playerlist_;
  playerlist_ = playerlist;
  if (playerlist) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.GameOver.playerList)
}

// optional .Proto.Map map = 2;
inline bool GameOver::has_map() const {
  return this != internal_default_instance() && map_ != NULL;
}
inline void GameOver::clear_map() {
  if (GetArenaNoVirtual() == NULL && map_ != NULL) delete map_;
  map_ = NULL;
}
inline const ::Proto::Map& GameOver::map() const {
  // @@protoc_insertion_point(field_get:Proto.GameOver.map)
  return map_ != NULL ? *map_
                         : *::Proto::Map::internal_default_instance();
}
inline ::Proto::Map* GameOver::mutable_map() {
  
  if (map_ == NULL) {
    map_ = new ::Proto::Map;
  }
  // @@protoc_insertion_point(field_mutable:Proto.GameOver.map)
  return map_;
}
inline ::Proto::Map* GameOver::release_map() {
  // @@protoc_insertion_point(field_release:Proto.GameOver.map)
  
  ::Proto::Map* temp = map_;
  map_ = NULL;
  return temp;
}
inline void GameOver::set_allocated_map(::Proto::Map* map) {
  delete map_;
  map_ = map;
  if (map) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.GameOver.map)
}

inline const GameOver* GameOver::internal_default_instance() {
  return &GameOver_default_instance_.get();
}
// -------------------------------------------------------------------

// ClientRequest

// optional .Proto.LoginRequest loginRequest = 1;
inline bool ClientRequest::has_loginrequest() const {
  return this != internal_default_instance() && loginrequest_ != NULL;
}
inline void ClientRequest::clear_loginrequest() {
  if (GetArenaNoVirtual() == NULL && loginrequest_ != NULL) delete loginrequest_;
  loginrequest_ = NULL;
}
inline const ::Proto::LoginRequest& ClientRequest::loginrequest() const {
  // @@protoc_insertion_point(field_get:Proto.ClientRequest.loginRequest)
  return loginrequest_ != NULL ? *loginrequest_
                         : *::Proto::LoginRequest::internal_default_instance();
}
inline ::Proto::LoginRequest* ClientRequest::mutable_loginrequest() {
  
  if (loginrequest_ == NULL) {
    loginrequest_ = new ::Proto::LoginRequest;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ClientRequest.loginRequest)
  return loginrequest_;
}
inline ::Proto::LoginRequest* ClientRequest::release_loginrequest() {
  // @@protoc_insertion_point(field_release:Proto.ClientRequest.loginRequest)
  
  ::Proto::LoginRequest* temp = loginrequest_;
  loginrequest_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_loginrequest(::Proto::LoginRequest* loginrequest) {
  delete loginrequest_;
  loginrequest_ = loginrequest;
  if (loginrequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ClientRequest.loginRequest)
}

// optional .Proto.CreateRoomRequest createRoom = 2;
inline bool ClientRequest::has_createroom() const {
  return this != internal_default_instance() && createroom_ != NULL;
}
inline void ClientRequest::clear_createroom() {
  if (GetArenaNoVirtual() == NULL && createroom_ != NULL) delete createroom_;
  createroom_ = NULL;
}
inline const ::Proto::CreateRoomRequest& ClientRequest::createroom() const {
  // @@protoc_insertion_point(field_get:Proto.ClientRequest.createRoom)
  return createroom_ != NULL ? *createroom_
                         : *::Proto::CreateRoomRequest::internal_default_instance();
}
inline ::Proto::CreateRoomRequest* ClientRequest::mutable_createroom() {
  
  if (createroom_ == NULL) {
    createroom_ = new ::Proto::CreateRoomRequest;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ClientRequest.createRoom)
  return createroom_;
}
inline ::Proto::CreateRoomRequest* ClientRequest::release_createroom() {
  // @@protoc_insertion_point(field_release:Proto.ClientRequest.createRoom)
  
  ::Proto::CreateRoomRequest* temp = createroom_;
  createroom_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_createroom(::Proto::CreateRoomRequest* createroom) {
  delete createroom_;
  createroom_ = createroom;
  if (createroom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ClientRequest.createRoom)
}

// optional .Proto.JoinRoomRequest joinRoom = 3;
inline bool ClientRequest::has_joinroom() const {
  return this != internal_default_instance() && joinroom_ != NULL;
}
inline void ClientRequest::clear_joinroom() {
  if (GetArenaNoVirtual() == NULL && joinroom_ != NULL) delete joinroom_;
  joinroom_ = NULL;
}
inline const ::Proto::JoinRoomRequest& ClientRequest::joinroom() const {
  // @@protoc_insertion_point(field_get:Proto.ClientRequest.joinRoom)
  return joinroom_ != NULL ? *joinroom_
                         : *::Proto::JoinRoomRequest::internal_default_instance();
}
inline ::Proto::JoinRoomRequest* ClientRequest::mutable_joinroom() {
  
  if (joinroom_ == NULL) {
    joinroom_ = new ::Proto::JoinRoomRequest;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ClientRequest.joinRoom)
  return joinroom_;
}
inline ::Proto::JoinRoomRequest* ClientRequest::release_joinroom() {
  // @@protoc_insertion_point(field_release:Proto.ClientRequest.joinRoom)
  
  ::Proto::JoinRoomRequest* temp = joinroom_;
  joinroom_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_joinroom(::Proto::JoinRoomRequest* joinroom) {
  delete joinroom_;
  joinroom_ = joinroom;
  if (joinroom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ClientRequest.joinRoom)
}

// optional .Proto.QuitGameRequest quitGame = 4;
inline bool ClientRequest::has_quitgame() const {
  return this != internal_default_instance() && quitgame_ != NULL;
}
inline void ClientRequest::clear_quitgame() {
  if (GetArenaNoVirtual() == NULL && quitgame_ != NULL) delete quitgame_;
  quitgame_ = NULL;
}
inline const ::Proto::QuitGameRequest& ClientRequest::quitgame() const {
  // @@protoc_insertion_point(field_get:Proto.ClientRequest.quitGame)
  return quitgame_ != NULL ? *quitgame_
                         : *::Proto::QuitGameRequest::internal_default_instance();
}
inline ::Proto::QuitGameRequest* ClientRequest::mutable_quitgame() {
  
  if (quitgame_ == NULL) {
    quitgame_ = new ::Proto::QuitGameRequest;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ClientRequest.quitGame)
  return quitgame_;
}
inline ::Proto::QuitGameRequest* ClientRequest::release_quitgame() {
  // @@protoc_insertion_point(field_release:Proto.ClientRequest.quitGame)
  
  ::Proto::QuitGameRequest* temp = quitgame_;
  quitgame_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_quitgame(::Proto::QuitGameRequest* quitgame) {
  delete quitgame_;
  quitgame_ = quitgame;
  if (quitgame) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ClientRequest.quitGame)
}

// optional .Proto.TileClickedRequest tileClicked = 5;
inline bool ClientRequest::has_tileclicked() const {
  return this != internal_default_instance() && tileclicked_ != NULL;
}
inline void ClientRequest::clear_tileclicked() {
  if (GetArenaNoVirtual() == NULL && tileclicked_ != NULL) delete tileclicked_;
  tileclicked_ = NULL;
}
inline const ::Proto::TileClickedRequest& ClientRequest::tileclicked() const {
  // @@protoc_insertion_point(field_get:Proto.ClientRequest.tileClicked)
  return tileclicked_ != NULL ? *tileclicked_
                         : *::Proto::TileClickedRequest::internal_default_instance();
}
inline ::Proto::TileClickedRequest* ClientRequest::mutable_tileclicked() {
  
  if (tileclicked_ == NULL) {
    tileclicked_ = new ::Proto::TileClickedRequest;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ClientRequest.tileClicked)
  return tileclicked_;
}
inline ::Proto::TileClickedRequest* ClientRequest::release_tileclicked() {
  // @@protoc_insertion_point(field_release:Proto.ClientRequest.tileClicked)
  
  ::Proto::TileClickedRequest* temp = tileclicked_;
  tileclicked_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_tileclicked(::Proto::TileClickedRequest* tileclicked) {
  delete tileclicked_;
  tileclicked_ = tileclicked;
  if (tileclicked) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ClientRequest.tileClicked)
}

// optional .Proto.TestRequest testRequest = 6;
inline bool ClientRequest::has_testrequest() const {
  return this != internal_default_instance() && testrequest_ != NULL;
}
inline void ClientRequest::clear_testrequest() {
  if (GetArenaNoVirtual() == NULL && testrequest_ != NULL) delete testrequest_;
  testrequest_ = NULL;
}
inline const ::Proto::TestRequest& ClientRequest::testrequest() const {
  // @@protoc_insertion_point(field_get:Proto.ClientRequest.testRequest)
  return testrequest_ != NULL ? *testrequest_
                         : *::Proto::TestRequest::internal_default_instance();
}
inline ::Proto::TestRequest* ClientRequest::mutable_testrequest() {
  
  if (testrequest_ == NULL) {
    testrequest_ = new ::Proto::TestRequest;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ClientRequest.testRequest)
  return testrequest_;
}
inline ::Proto::TestRequest* ClientRequest::release_testrequest() {
  // @@protoc_insertion_point(field_release:Proto.ClientRequest.testRequest)
  
  ::Proto::TestRequest* temp = testrequest_;
  testrequest_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_testrequest(::Proto::TestRequest* testrequest) {
  delete testrequest_;
  testrequest_ = testrequest;
  if (testrequest) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ClientRequest.testRequest)
}

// optional .Proto.QuitRoom quitRoom = 7;
inline bool ClientRequest::has_quitroom() const {
  return this != internal_default_instance() && quitroom_ != NULL;
}
inline void ClientRequest::clear_quitroom() {
  if (GetArenaNoVirtual() == NULL && quitroom_ != NULL) delete quitroom_;
  quitroom_ = NULL;
}
inline const ::Proto::QuitRoom& ClientRequest::quitroom() const {
  // @@protoc_insertion_point(field_get:Proto.ClientRequest.quitRoom)
  return quitroom_ != NULL ? *quitroom_
                         : *::Proto::QuitRoom::internal_default_instance();
}
inline ::Proto::QuitRoom* ClientRequest::mutable_quitroom() {
  
  if (quitroom_ == NULL) {
    quitroom_ = new ::Proto::QuitRoom;
  }
  // @@protoc_insertion_point(field_mutable:Proto.ClientRequest.quitRoom)
  return quitroom_;
}
inline ::Proto::QuitRoom* ClientRequest::release_quitroom() {
  // @@protoc_insertion_point(field_release:Proto.ClientRequest.quitRoom)
  
  ::Proto::QuitRoom* temp = quitroom_;
  quitroom_ = NULL;
  return temp;
}
inline void ClientRequest::set_allocated_quitroom(::Proto::QuitRoom* quitroom) {
  delete quitroom_;
  quitroom_ = quitroom;
  if (quitroom) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Proto.ClientRequest.quitRoom)
}

inline const ClientRequest* ClientRequest::internal_default_instance() {
  return &ClientRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// QuitRoom

// optional int32 token = 1;
inline void QuitRoom::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 QuitRoom::token() const {
  // @@protoc_insertion_point(field_get:Proto.QuitRoom.token)
  return token_;
}
inline void QuitRoom::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:Proto.QuitRoom.token)
}

inline const QuitRoom* QuitRoom::internal_default_instance() {
  return &QuitRoom_default_instance_.get();
}
// -------------------------------------------------------------------

// TestRequest

// optional int32 token = 1;
inline void TestRequest::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 TestRequest::token() const {
  // @@protoc_insertion_point(field_get:Proto.TestRequest.token)
  return token_;
}
inline void TestRequest::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:Proto.TestRequest.token)
}

inline const TestRequest* TestRequest::internal_default_instance() {
  return &TestRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// QuitGameRequest

// optional int32 token = 1;
inline void QuitGameRequest::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 QuitGameRequest::token() const {
  // @@protoc_insertion_point(field_get:Proto.QuitGameRequest.token)
  return token_;
}
inline void QuitGameRequest::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:Proto.QuitGameRequest.token)
}

inline const QuitGameRequest* QuitGameRequest::internal_default_instance() {
  return &QuitGameRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// TileClickedRequest

// optional int32 token = 1;
inline void TileClickedRequest::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 TileClickedRequest::token() const {
  // @@protoc_insertion_point(field_get:Proto.TileClickedRequest.token)
  return token_;
}
inline void TileClickedRequest::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:Proto.TileClickedRequest.token)
}

// optional int32 tileIndex = 2;
inline void TileClickedRequest::clear_tileindex() {
  tileindex_ = 0;
}
inline ::google::protobuf::int32 TileClickedRequest::tileindex() const {
  // @@protoc_insertion_point(field_get:Proto.TileClickedRequest.tileIndex)
  return tileindex_;
}
inline void TileClickedRequest::set_tileindex(::google::protobuf::int32 value) {
  
  tileindex_ = value;
  // @@protoc_insertion_point(field_set:Proto.TileClickedRequest.tileIndex)
}

inline const TileClickedRequest* TileClickedRequest::internal_default_instance() {
  return &TileClickedRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// JoinRoomRequest

// optional int32 token = 1;
inline void JoinRoomRequest::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 JoinRoomRequest::token() const {
  // @@protoc_insertion_point(field_get:Proto.JoinRoomRequest.token)
  return token_;
}
inline void JoinRoomRequest::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:Proto.JoinRoomRequest.token)
}

// optional int32 roomNumber = 2;
inline void JoinRoomRequest::clear_roomnumber() {
  roomnumber_ = 0;
}
inline ::google::protobuf::int32 JoinRoomRequest::roomnumber() const {
  // @@protoc_insertion_point(field_get:Proto.JoinRoomRequest.roomNumber)
  return roomnumber_;
}
inline void JoinRoomRequest::set_roomnumber(::google::protobuf::int32 value) {
  
  roomnumber_ = value;
  // @@protoc_insertion_point(field_set:Proto.JoinRoomRequest.roomNumber)
}

inline const JoinRoomRequest* JoinRoomRequest::internal_default_instance() {
  return &JoinRoomRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// CreateRoomRequest

// optional int32 token = 1;
inline void CreateRoomRequest::clear_token() {
  token_ = 0;
}
inline ::google::protobuf::int32 CreateRoomRequest::token() const {
  // @@protoc_insertion_point(field_get:Proto.CreateRoomRequest.token)
  return token_;
}
inline void CreateRoomRequest::set_token(::google::protobuf::int32 value) {
  
  token_ = value;
  // @@protoc_insertion_point(field_set:Proto.CreateRoomRequest.token)
}

inline const CreateRoomRequest* CreateRoomRequest::internal_default_instance() {
  return &CreateRoomRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// LoginRequest

// optional string login = 1;
inline void LoginRequest::clear_login() {
  login_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::login() const {
  // @@protoc_insertion_point(field_get:Proto.LoginRequest.login)
  return login_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_login(const ::std::string& value) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LoginRequest.login)
}
inline void LoginRequest::set_login(const char* value) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LoginRequest.login)
}
inline void LoginRequest::set_login(const char* value, size_t size) {
  
  login_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LoginRequest.login)
}
inline ::std::string* LoginRequest::mutable_login() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LoginRequest.login)
  return login_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_login() {
  // @@protoc_insertion_point(field_release:Proto.LoginRequest.login)
  
  return login_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_login(::std::string* login) {
  if (login != NULL) {
    
  } else {
    
  }
  login_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), login);
  // @@protoc_insertion_point(field_set_allocated:Proto.LoginRequest.login)
}

// optional string password = 2;
inline void LoginRequest::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LoginRequest::password() const {
  // @@protoc_insertion_point(field_get:Proto.LoginRequest.password)
  return password_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Proto.LoginRequest.password)
}
inline void LoginRequest::set_password(const char* value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Proto.LoginRequest.password)
}
inline void LoginRequest::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Proto.LoginRequest.password)
}
inline ::std::string* LoginRequest::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:Proto.LoginRequest.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_password() {
  // @@protoc_insertion_point(field_release:Proto.LoginRequest.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:Proto.LoginRequest.password)
}

inline const LoginRequest* LoginRequest::internal_default_instance() {
  return &LoginRequest_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Proto::GameState> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Proto::GameState>() {
  return ::Proto::GameState_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ProtoMessages_2eproto__INCLUDED
